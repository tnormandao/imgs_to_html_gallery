<html>
  <head>
    <style>
      body{
        font-family: monospace;
      }
      #inspect_gallery{
        width: 1280px; 
        height: 600px; 
        border: 1px solid #333; 
        overflow-y: scroll;
      }
      .editable_container{
        margin: 10px 0px;
        position: relative;
        width: 1255px;
        height: 386px;
        display: inline-block;
        clear: left;
      }
      .editable_img{
        max-width: 740px;
        height: 386px;
        float: left;
      }
      .editable__prompt_container{
        position: absolute;
        right: 0;
        width: 513px;
      }
      .editable_pos, .editable_neg, .editable_cfg{
        width: 512px;
        height: 128px;
      }
    </style>
  </head>
  <body>
    <h3 > Convert images into singlie ".html" file gallery </h3>
    <h4 style="color:#999;"> also will save metadatta from a1111 generated files </h3>
    chose result jpg quality: <input id="jpg_quality" type="range" min="0.01" max="1" step="0.01" value="0.2"> : <input id="jpg_quality_num" type="number" min="0.01" max="1" step="0.01" value="0.2"><br>
    <hr>
    select images for pack gallery: <input type="file" id="load_files" multiple/><span id="processed"></span><br>
    <hr>
    <a href="" id="get_result_gallery" > download result gallery html </a> | <button id="test_gallery" > test gallery in popup window </button><br>
    <h3>html_gallery inspector</h3>
    <h4 style="color:#999;">inspect and edit before download html_gallery</h3>
    <div style="" id="inspect_gallery">
    </div>
    <script>

        const pngMetadata = new function(){

          // source code
          // https://github.com/kujirahand/node-png-metadata
          var metadata = {};

          // var fs = require('fs');

          metadata.PNG_SIG = String.fromCharCode(0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a);

          // read pngfile by binary
          metadata.readFileSync = function (path) {
            // var buf = fs.readFileSync(path, "binary");
            // return buf;
          };
          metadata.writeFileSync = function (path, bin) {
            // fs.writeFileSync(path, bin, "binary");
          };

          // check PNG signature
          metadata.isPNG = function (s) {
            var sig = s.substr(0, 8);
            return (sig == metadata.PNG_SIG);
          };

          metadata.splitChunk= function (s) {
            // read signature
            var sig = s.substr(0, 8);
            if (!metadata.isPNG(sig)) return false;
            s = s.substr(8); // chomp sig
            var chunklist = [];
            // read chunk list
            while (s != '') {
              var chunk = {};
              // read chunk size
              var size = stoi(s.substr(0, 4));
              if (size < 0) {
                // If the size is negative, the data is likely corrupt, but we'll let
                // the caller decide if any of the returned chunks are usable.
                // We'll move forward in the file with the minimum chunk length (12 bytes).
                size = 0;
              }
              var buf = s.substr(0, size + 12);
              s = s.substr(size + 12); // delete this chunk
              // read chunk data
              chunk.size = size;
              chunk.type = buf.substr(4, 4);
              chunk.data = buf.substr(8, size);
              chunk.crc  = stoi(buf.substr(8 + size, 4));
              // add chunk
              chunklist.push(chunk);
            }
            return chunklist;
          };

          metadata.joinChunk = function (chunklist) {
            var pf = metadata.PNG_SIG;
            for (var i in chunklist) {
              var chunk = chunklist[i];
              // check size
              // chunk.size = chunk.data.length;
              // calc crc
              // var crc_v = crc32(chunk.type + chunk.data);
              // 
              var buf = "";
              buf += itos(chunk.size, 4);
              buf += chunk.type;
              buf += chunk.data;
              buf += itos(chunk.crc, 4);
              // console.log("w", chunk.size, chunk.type, ToUInt32(chunk.crc));
              pf += buf;
            }
            return pf;
          };

          metadata.createChunk = function (type, data) {
            var c = {};
            c.type = type;
            c.data = data;
            c.size = data.length;
            c.crc  = crc32(type+data);
            return c;
          };

          metadata.itos = itos;
          function itos(v, size) {
            var a = [];
            var t = size - 1;
            while (t >= 0) {
              var c = v & 0xFF;
              a[t--] = c;
              v = v >> 8;
            }
            a = a.map(function(v) {
              return String.fromCharCode(v);
            });
            return a.join('');
          }

          metadata.stoi = stoi;
          function stoi(s) {
            var v = 0;
            for (var i = 0; i < s.length; i++) {
              var c = s.charCodeAt(i);
              v = (v << 8) | (c & 0xFF);
            }
            return v;
          }

          function ToInt32(x) {
            return x | 0;
          }
          function ToUInt32(x) {
            return x >>> 0;
          }

          function crc32(str) {
            var hexTable = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D]
            var crc = 0 ^ (-1);
            for (var i = 0; i < str.length; i++) {
              crc = (crc >>> 8) ^ hexTable[(crc ^ str.charCodeAt(i)) & 0xFF];
            }
            return (crc ^ (-1)) >>> 0;
          }

          return metadata;

        };

        const HTML_TEMPLATE = `
        <html>
              <head>
                <style>
                  #text_info{
                    width: 512px;
                    float: right;
                  }
                  .info_area{
                    width: 512px;
                    height: 128px;
                  }
                </style>
              </head>
              <body>
                <input id="slide" style="width: 768px;" type="range" min="0" max="0.9999" step="0.0001" value="0"><span id="frame_counter"></span>
                <button id="play_frames">play</button> | fps: <input value="1" id="frame_per_second" type="number" min="0.1" max="60" step="0.1" /><br>
                <div style="width:1282px;">
                  <div id="text_info">
                    <textarea class="info_area" id="text_positive"></textarea>
                    <textarea class="info_area" id="text_negative"></textarea>
                    <textarea class="info_area" id="text_config"></textarea>
                  </div>
                  <div style="width:768px;">
                    <img style="width: 100%;" id="display">
                  </div>
                </div>
                <SCRPT>
                  const f = FRAMES_JSON;
                  const t = TEXT_JSON;
                  const $$ = (id) => { return document.getElementById( id ); };
                  let CURRENT_FRAME = 0;
                  const setFrame = ( frameIndex, updateSlider ) => {
                    CURRENT_FRAME = frameIndex;
                    $$('slide').value = ( frameIndex + 1 ) / f.length;
                    $$('display').src = f[ frameIndex ]; 
                    $$('text_positive').innerText = t[ frameIndex ].positive;
                    $$('text_negative').innerText = t[ frameIndex ].negative;
                    $$('text_config').innerText = t[ frameIndex ].config;
                    $$('frame_counter').innerText = (1 + frameIndex) + ' : ' + f.length;
                  };
                  window.onload = ()=> { 
                    setFrame( CURRENT_FRAME );
                    $$('slide').addEventListener( 'input', () => { 
                      const frameIndex = Math.floor( f.length * $$('slide').value );
                      setFrame(frameIndex);
                    } ); 
                    const player = {
                      active: false,
                      speed: 1,
                      player: null,
                      play: function(){
                        this.active = !this.active;
                        if( this.active ){
                          $$('play_frames').innerText = 'pause';
                          this.speed = $$('frame_per_second').value;
                          this.next();
                        } else {
                          $$('play_frames').innerText = 'play';
                          if( this.player ) clearTimeout( this.player );
                        }
                      },
                      next: function(){
                        this.speed = $$('frame_per_second').value;
                        const nextInterval = 1000 / this.speed;
                        this.player = setTimeout( () => {
                          if( CURRENT_FRAME + 1 < f.length ){
                            setFrame( CURRENT_FRAME + 1, true );
                            this.next();
                          } else {
                            this.play();
                          }
                        }, nextInterval );
                      }
                    };
                    $$('play_frames').addEventListener( 'click', () => { player.play() } );
                  };
                </SCRPT>
              </body>
            </html>
        `;

        let FRAMES_BUFFER_ARRAY = [];
        let TEXT_BUFFER_ARRAY = [];

        function dateNow(){
          const date = new Date();
          let year = date.getFullYear();
          let month = ( date.getMonth() + '' ).length === 1 ? '0' + ( date.getMonth() + 1 ) : date.getMonth() + 1;
          let day = ( date.getDate() + '' ).length === 1 ? '0' + date.getDate(): date.getDate();
          let hours = ( date.getHours() + '' ).length === 1 ? '0' + date.getHours(): date.getHours();
          let minutes = ( date.getMinutes() + '' ).length === 1 ? '0' + date.getMinutes(): date.getMinutes();
          let seconds = ( date.getSeconds() + '' ).length === 1 ? '0' + date.getSeconds(): date.getSeconds();
          const combined_string = `${year}${month}${day}-${hours}${minutes}${seconds}`;
          return combined_string;
        }

        window.onload = () => {

          const $$ = (id) => { return document.getElementById( id ); };

          const processingCanvas = document.createElement('canvas');
          const processingContext = processingCanvas.getContext('2d');
          const processingImage = new Image();

          const processSinglePicture = async ( nextDataPack, FRAMES_BUFFER_ARRAY, TEXT_BUFFER_ARRAY ) => {
            return new Promise( async ( resolveProcessing, rejectProcessing ) => {
              // console.log( nextDataPack );
              const metadata = pngMetadata.splitChunk( nextDataPack.buffer );
              // console.log( metadata );
               let textOptions = {
                positive: '',
                negative: '',
                config: '',
              };
              if( metadata && metadata[1] && metadata[1].type == 'tEXt' ){
                const dataArr = metadata[1].data.split('\n');
                let _state = 'positive'; // positive | negative | config
                for( let i = 0; i < dataArr.length; i++ ){
                  if( dataArr[i] === '' ){ continue; }        
                  if( dataArr[i].includes( 'parameters\x00' ) ){ _state = 'positive'; dataArr[i] = dataArr[i].replace('parameters\x00', '' ); }
                  if( dataArr[i].includes( 'Negative prompt:' ) ){ _state = 'negative'; dataArr[i] = dataArr[i].replace('Negative prompt:', '' ); }
                  if( dataArr[i].includes( 'Steps: ' ) ){ _state = 'config'; } 
                  if( _state === 'positive' ){
                    textOptions.positive += ' ' + dataArr[i];
                  } else if(  _state === 'negative'  ) {
                    textOptions.negative += ' ' + dataArr[i];
                  } else if(  _state === 'config'  ) {
                    textOptions.config += ' ' + dataArr[i];
                  }
                }
                TEXT_BUFFER_ARRAY.push( textOptions );
              } else {
                TEXT_BUFFER_ARRAY.push( textOptions );
              }

              await new Promise( async ( resolveImageConversion, rejectImageConversion )=>{
                const fr = new FileReader();
                fr.onload = () => {
                  processingImage.onload = () => {
                    const nextImg = processingImage;
                    processingCanvas.width = nextImg.width;
                    processingCanvas.height = nextImg.height;
                    processingContext.drawImage( 
                      nextImg,
                      0, 0, nextImg.width, nextImg.height,
                      0, 0, nextImg.width, nextImg.height
                    );
                    const quality = parseFloat( $$('jpg_quality').value );
                    const nextDataUrl = processingCanvas.toDataURL( "image/jpeg", quality );
                    FRAMES_BUFFER_ARRAY.push( nextDataUrl );
                    resolveImageConversion();
                  };
                  processingImage.src = fr.result;
                };
                fr.readAsDataURL( nextDataPack.file );
              } );

              resolveProcessing();
            } );
          };

          const processFiles = async ( files ) => {
            const baseForWork = [];
            for( const nextFile of files ){
              await new Promise( ( resolve, reject ) => {
                const reader = new FileReader()
                reader.onload = () => {
                  const buffer = reader.result;
                  const { name, type, size,} = nextFile;
                  baseForWork.push( {
                    file: nextFile,
                    buffer,
                    name,
                    type,
                    size,
                  } );
                  resolve();
                };
                reader.readAsBinaryString( nextFile );
              } );
            }
            let next = 0;
            for( const nextDataPack of baseForWork ){
              const nextData = await processSinglePicture( nextDataPack, FRAMES_BUFFER_ARRAY, TEXT_BUFFER_ARRAY );
              next++;
              $$('processed').innerText = next + ' : ' + files.length;
            }
          };

          let TEMPLATE = '';
          let WIN_URL = '';

          const updateTemplate = async ( openPopup ) => {

            TEMPLATE = HTML_TEMPLATE + '';

            TEMPLATE = TEMPLATE.replaceAll( 'SCRPT', 'script' );
            TEMPLATE = TEMPLATE.replace( 'FRAMES_JSON', JSON.stringify( FRAMES_BUFFER_ARRAY, null, 2 ) );
            TEMPLATE = TEMPLATE.replace( 'TEXT_JSON', JSON.stringify( TEXT_BUFFER_ARRAY, null, 2 ) );

            const galleryBlob = new Blob([ TEMPLATE ], { type: "text/html" });

            WIN_URL = URL.createObjectURL( galleryBlob );

            const a = $$("get_result_gallery");
            a.href = WIN_URL;
            a.download = dateNow() + '_gallery.html';

          };

          const openPopup = () => {
            updateTemplate();
            const win = window.open( 
              WIN_URL, 
              "Title", 
              "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=1280,height=512,top="+(screen.height-400)+",left="+(screen.width-840));
          }

          const createInspectorModule = ( dataIndex ) => {
            
            const container = document.createElement('div');
            container.classList.add('editable_container');

            const nextImage = new Image();
            nextImage.src = FRAMES_BUFFER_ARRAY[ dataIndex ];
            nextImage.classList.add('editable_img');
            container.appendChild( nextImage );

            const promptContainer = document.createElement('div');
            promptContainer.classList.add('editable__prompt_container');
            container.appendChild( promptContainer );

            const posT = document.createElement('textarea');
            posT.classList.add('editable_pos');
            posT.value = TEXT_BUFFER_ARRAY[ dataIndex ].positive;
            posT.addEventListener( 'input', () => { 
              TEXT_BUFFER_ARRAY[ dataIndex ].positive = posT.value; 
              // updateTemplate();
            } );
            promptContainer.appendChild( posT );

            const negT = document.createElement('textarea');
            negT.classList.add('editable_neg');
            negT.value = TEXT_BUFFER_ARRAY[ dataIndex ].negative;
            negT.addEventListener( 'input', () => { 
              TEXT_BUFFER_ARRAY[ dataIndex ].negative = negT.value; 
              // updateTemplate();
            } );
            promptContainer.appendChild( negT );

            const cfgT = document.createElement('textarea');
            cfgT.classList.add('editable_cfg');
            cfgT.value = TEXT_BUFFER_ARRAY[ dataIndex ].config;
            cfgT.addEventListener( 'input', () => { 
              TEXT_BUFFER_ARRAY[ dataIndex ].config = cfgT.value; 
              // updateTemplate();
            } );
            promptContainer.appendChild( cfgT );


            return container;
          };

          $$('test_gallery').addEventListener( 'click', () => {
            openPopup();
          } );

          $$("get_result_gallery").addEventListener( 'click', () => {
            updateTemplate();
          } );


          $$('load_files').addEventListener( 'change', async () => { 
            
            FRAMES_BUFFER_ARRAY = [];
            TEXT_BUFFER_ARRAY = [];

            const files = $$('load_files').files;
            await processFiles( files );

            updateTemplate();

            $$('load_files').value = null;

            $$( 'inspect_gallery' ).innerHTML = '';

            for( let i = 0; i < FRAMES_BUFFER_ARRAY.length; i++ ){
              const nextEditableInspectorModule = createInspectorModule( i );
              $$( 'inspect_gallery' ).appendChild( nextEditableInspectorModule );
            }
            
          } ); 

          $$('jpg_quality_num').addEventListener( 'input', () => {
            if( $$('jpg_quality_num').value < $$('jpg_quality_num').min ){ $$('jpg_quality_num').value =  $$('jpg_quality_num').min; }
            if( $$('jpg_quality_num').value > $$('jpg_quality_num').max ){ $$('jpg_quality_num').value =  $$('jpg_quality_num').max; }
            $$('jpg_quality').value = $$('jpg_quality_num').value;
          } );

          $$('jpg_quality').addEventListener( 'input', () => {
            $$('jpg_quality_num').value = $$('jpg_quality').value;
          } );

        }
    </script>
  </body>
</html>
